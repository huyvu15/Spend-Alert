[
{
	"uri": "//localhost:1313/1-introduce/1.1-subnets/",
	"title": "API",
	"tags": [],
	"description": "",
	"content": "Giới thiệu API API là viết tắt của Application Programming Interface (Giao diện lập trình ứng dụng), một phần mềm trung gian cho phép hai ứng dụng nói chuyện với nhau. Mỗi khi sử dụng một ứng dụng như Facebook, gửi tin nhắn tức thì hoặc kiểm tra thời tiết trên điện thoại, có nghĩa là bạn đang sử dụng API.\nĐể hình dung dễ hiểu hơn về API thì mọi người hình dung API nó giống như một cái hàm và có tham số cụ thể(Nếu không có giới hạn tham số thì API có thể yêu cầu mọi từ server).\nTùy theo loại API mà có giới hạn requests truy cập riêng\nServer thì như một đôi tai liên tục lắng nghe tin hiệu từ API và trả về những thứ theo yêu cầu thực hiện của API\n"
},
{
	"uri": "//localhost:1313/1-introduce/",
	"title": "Giới thiệu",
	"tags": [],
	"description": "",
	"content": "Nhận thông báo chi tiêu cho hoạt động mua sắp tại Shopee Tổng quan Chúng ta đều biết rằng việc tự động hóa các quy trình kinh doanh có thể mang lại nhiều lợi ích về mặt thời gian, hiệu quả và tiết kiệm chi phí và rất nhiều sự tiện dụng. Trong bài workshop hôm nay, chúng ta sẽ tập trung vào việc xây dựng một hệ thống gửi thông báo số tiền đã chi cho các hoạt động mua sắp trên Shopee thông qua Gmail, bằng cách sử dụng các dịch vụ mạnh mẽ của Amazon Web Services (AWS).\nĐồng thời chúng ta cùng làm quen với các Services phổ biến như sau:\n1. AWS Lambda Function: Lambda Function cho phép chúng ta thực thi mã một cách linh hoạt mà không cần quản lý máy chủ.\n2. Amazon EventBridge: EventBridge giúp chúng ta lên lịch và kiểm soát các sự kiện trong hệ thống của mình như điều khiển các lambda function chạy vào mỗi đầu tháng.\n3. Amazon S3: S3 là một trong số các dịch vụ lưu trữ đám mây của AWS. Là một trong những giải pháp hữu hiệu để xây dựng data lake cho doanh nghiệp. Trong phần thực hành này S3 sẽ được sử dụng để lưu trữ các tệp đính kèm trong các email mà chúng ta sẽ gửi(file dữ liệu, ảnh phân tích).\nTuy nhiên để đơn giản và demo một cách thuận tiện nhất có thể bài lab chỉ gửi thông báo số tiền chi tiêu trong tháng trước thông qua email. Do một ngày mình check email khá nhiều nên mình quyết định dùng nền tảng này để thực hiện. Ngoài ra có thể gửi thông báo qua zalo, telegram thông qua api.\nNgôn ngữ chính để phục vụ workshop này là python 3.10\nÝ tưởng: Crawl dữ liệu từ đơn mua hàng cá nhân trên shopee đẩy dữ liệu vào S3, dùng thư viện pandas để xử lý dữ liệu và tính toán để trả về số tiền đã chi tiêu trong tháng trước đó. Dùng EventBridge để hẹn giờ chạy Lambda Function.\nNội dung Giới thiệu Tường lửa trong VPC Các bước chuẩn bị Lấy cookie từ shopee Tạo schedule cho EventBridge Dọn dẹp tài nguyên Bây giờ chúng ta sẽ cùng nhau đi qua các khái niệm cơ bản nhất của Lambda Function nhé.\n"
},
{
	"uri": "//localhost:1313/4-createec2server/4.1-createec2/",
	"title": "Lấy mật khẩu ứng dụng Gmail",
	"tags": [],
	"description": "",
	"content": "Lấy mật khẩu ứng dụng Gmail Lấy mật khẩu ứng dụng theo hướng dẫn tại link: https://www.youtube.com/watch?v=fG43VdSGQX8\u0026amp;t=426s.\nSau đó lưu vào đâu đó để sau còn sửa code.\nPASSWORD = \u0026quot; \u0026quot;\n"
},
{
	"uri": "//localhost:1313/",
	"title": "Nhận thông báo chi tiêu cho hoạt động mua sắp tại Shopee",
	"tags": [],
	"description": "",
	"content": "Nhận thông báo chi tiêu cho hoạt động mua sắp tại Shopee Tổng quan Chúng ta đều biết rằng việc tự động hóa các quy trình kinh doanh có thể mang lại nhiều lợi ích về mặt thời gian, hiệu quả và tiết kiệm chi phí và rất nhiều sự tiện dụng. Trong bài workshop hôm nay, chúng ta sẽ tập trung vào việc xây dựng một hệ thống gửi thông báo số tiền đã chi cho các hoạt động mua sắp trên Shopee thông qua Gmail, bằng cách sử dụng các dịch vụ mạnh mẽ của Amazon Web Services (AWS).\nĐồng thời chúng ta cùng làm quen với các Services phổ biến như sau:\n1. AWS Lambda Function: Lambda Function cho phép chúng ta thực thi mã một cách linh hoạt mà không cần quản lý máy chủ.\n2. Amazon EventBridge: EventBridge giúp chúng ta lên lịch và kiểm soát các sự kiện trong hệ thống của mình như điều khiển các lambda function chạy vào mỗi đầu tháng.\n3. Amazon S3: S3 là một trong số các dịch vụ lưu trữ đám mây của AWS. Là một trong những giải pháp hữu hiệu để xây dựng data lake cho doanh nghiệp. Trong phần thực hành này S3 sẽ được sử dụng để lưu trữ các tệp đính kèm trong các email mà chúng ta sẽ gửi(file dữ liệu, ảnh phân tích).\nTuy nhiên để đơn giản và demo một cách thuận tiện nhất có thể bài lab chỉ gửi thông báo số tiền chi tiêu trong tháng trước thông qua email. Do một ngày mình check email khá nhiều nên mình quyết định dùng nền tảng này để thực hiện. Ngoài ra có thể gửi thông báo qua zalo, telegram thông qua api.\nNgôn ngữ chính để phục vụ workshop này là python 3.10\nNội dung Giới thiệu Tường lửa trong VPC Các bước chuẩn bị Lấy Cookie từ shopee Tạo schema cho EventBridge Dọn dẹp tài nguyên "
},
{
	"uri": "//localhost:1313/2-firewallinvpc/2.1-securitygroup/",
	"title": "Security Group",
	"tags": [],
	"description": "",
	"content": "Security Group Một số đặc điểm cơ bản của Security group:\nChỉ có thể thêm vào các Allow rule, mà không thể bổ sung Deny rule. Có thể chỉ định các rule riêng biệt cho lưu lượng truy cập đi ra hoặc đi vào. Một Security group mới được tạo ra không có sẵn Inbound rules. Do đó, tại thời điểm ban đầu Instance sẽ không cho phép bất cứ lưu lượng truy cập nào được phép đi vào, đòi hỏi ta phải bổ sung Inbound rule để cấp phép truy cập. Mặc định, Security group có sẵn Outbound rule cho phép mọi lưu lượng được phép đi ra khỏi Instance. Rule này có thể được chỉnh sửa (xóa) và bổ sung các Outbound rule cụ thể, chỉ rõ lưu lượng nào xuất phát từ Instance được phép đi ra ngoài. Nếu SG không có Outbound rule thì không một lưu lượng nào được phép đi ra khỏi Instance. Security groups là một dịch vụ Stateful - nghĩa là nếu lưu lượng đi vào Instance đã được cấp phép thì lưu lượng cũng có thể đi ra ngoài Instance, và ngược lại, bất kể Outbound rule như thế nào. Các Instance chỉ có thể giao tiếp được với nhau khi và chỉ khi chúng được liên kết với Security group cho phép kết nối, hoặc Security group mà Instance có liên kết chứa Rule cho phép lưu lượng try cập (ngoại trừ Security group mặc định với có các rule mặc định cho phép toàn bộ lưu lượng được truy cập). Security group được liên kết với các network interface. Sau khi Instance đã được khởi tạo, ta vẫn có thể thay đổi Security group đã được gán với Instance, điều này cũng thay đổi security group đang được gán với primary network interface tương ứng. Security group Rule Rule được sinh ra để cấp quyền truy cập cho lưu lượng đi vào hoặc đi ra khỏi Instance. Quyền truy cập này có thể được áp dụng cho một CIDR cụ thể hoặc cho một Security group nằm trong cùng một VPC hoặc nằm trong một VPC khác nhưng có kết nối peering đã được khởi tạo.\nCác thành phần cơ bản của Security group rule:\n(Chỉ đối với Inbound rules) gồm điểm xuất phát (nguồn) của lưu lượng truy cập và port đích hoặc dải port. Nguồn có thể là một security group khác, là một dải IPv4 hoặc IPv6 CIDR hoặc đơn thuẩn là một địa chỉ IPv4 hoặc IPv6. (Chỉ đối với Outbound rules) gồm đích đến của lưu lượng và port đích hay dải port đích. Đích đến có thể là một security group khác, là một dải IPv4 hoặc IPv6 CIDR hoặc đơn thuẩn là một địa chỉ IPv4 hoặc IPv6 hoặc là một dịch vụ bắt đầu bằng một tiền tố (ví dụ: igw_xxx) nằm trong danh sách prefix ID(một dịch vụ được xác định bởi prefix ID - tên và ID của dịch vụ khả dụng trong region). Mọi giao thức đều có một số giao thức chuẩn. Ví dụ: SSH là 22,.. "
},
{
	"uri": "//localhost:1313/3-prerequiste/3.1-createvpc/",
	"title": "Tạo S3 Bucket",
	"tags": [],
	"description": "",
	"content": "Tạo S3 Bucket Truy cập giao diện AWS Management Console\nTìm S3 Chọn Bucket Chọn Create Bucket Điền các thông tin cho Buket\nĐặt tên Bucket là workshoph Tên Bucket phải là duy nhất và không được trùng với tên các bucket đã có.\nKéo xuống cuối và chọn Create Bucket "
},
{
	"uri": "//localhost:1313/1-introduce/1.2-routetable/",
	"title": "Crawl data",
	"tags": [],
	"description": "",
	"content": "Crawl data Crawl data là quá trình tự động thu thập thông tin từ các trang web trên Internet. Để hiểu cách nó hoạt động, hãy tưởng tượng rằng bạn có một robot trên mạng Internet, nhiệm vụ của nó là thu thập thông tin từ các trang web.\nRobot bắt đầu bằng việc điều hướng qua các trang web, như một người du lịch dạo chơi qua các con đường trên bản đồ. Khi robot đến một trang web, nó quét qua nội dung của trang đó, giống như việc bạn đọc qua các trang sách để tìm kiếm thông tin. Robot phân tích các phần tử của trang web như các liên kết, văn bản, hình ảnh, video, và dữ liệu cấu trúc.\nSau đó, robot thu thập dữ liệu từ các phần của trang web chứa thông tin bạn quan tâm, như việc bạn ghi chú lại những điều quan trọng khi đọc sách. Dữ liệu này có thể là văn bản, hình ảnh, video, hoặc dữ liệu có cấu trúc như bảng biểu.\nQuá trình này được lặp lại cho đến khi robot đã thu thập đủ thông tin hoặc đã truy cập qua tất cả các trang web trong danh sách. Đối với những trang web thường xuyên cập nhật thông tin, bạn có thể lập lịch cho robot để thực hiện lại quá trình crawl định kỳ để đảm bảo dữ liệu của bạn luôn cập nhật.\nTuy nhiên, việc crawl data cần phải được thực hiện cẩn thận và tuân thủ các quy định về bản quyền và chính sách riêng tư của các trang web. Vi phạm các quy định này có thể dẫn đến hậu quả pháp lý.\nCứ cái gì nhìn thấy trên web thì đều có thể lấy về bằng code được .\n"
},
{
	"uri": "//localhost:1313/2-firewallinvpc/2.2-networkacls/",
	"title": "Network ACLs",
	"tags": [],
	"description": "",
	"content": "Network ACLs VPC sau khi khởi tạo sẽ có sẵn một network ACL mặc định và có thể được sửa đổi. Mặc định, nó cấp phép truy cập cho tất cả lưu lượng truy cập IPv4 hoặc IPv6 có thể đi ra hoặc đi vào VPC. Có thể tạo một network ACL tùy chỉnh và liên kết nó với một subnet. Mặc định các network ACL tùy chỉnh từ chối tất cả lưu lượng truy cập đi vào và đi ra, cho đến khi ta bổ sung rule cấp phép truy cập. Từng subnet trong VPC phải được liên kết với một network ACL. Nếu subnet không được liên kết với một network ACL cụ thể thì subnet sẽ được tự động liên kết với network ACL mặc định. Một network ACL có thể liên kết với nhiều subnet. Tuy nhiên, một subnet chỉ có thể liên kết với một network ACL tại một thời điểm. Khi liên kết network ACL mới với subnet,thì liên kết trước đó sẽ bị xóa. Một network ACL chứa một danh sách các rule được đánh số khác nhau. AWS đánh giá các rule dựa trên số thứ tự được gán, bắt đầu với rule được đánh số thấp nhất, để xác định xem lưu lượng có được phép đi vào hay đi ra khỏi bất kỳ subnet nào được liên kết với network ACL hay không. Số thứ tự lớn nhất có thể được gán cho rule là 32766 (tương đương số lượng rule lớn nhất của một network ACL là 32766). Network ACL có các rule cấp phép đi vào hoặc đi ra tách biệt và rule có thể là cho phép hoặc từ chối lưu lượng. Network ACL là dịch vụ Stateless, nghĩa là phản hồi đối với lưu lượng truy cập được phép đi vào, phải tuân theo rule đối với lưu lượng truy cập đi ra (và ngược lại). Network ACL rules Có thể thêm hoặc xóa một rule khỏi network ACL mặc định hoặc tạo network ACL mới cho VPC. Khi thêm hoặc xóa một rule khỏi network ACL, các thay đổi sẽ tự động được áp dụng cho các subnet được liên kết với nó.\nCác thành phần của một network ACL rule:\nRule number. Rule bắt đầu được đánh giá bắt đầu với rule có số thứ tự thấp nhất. Ngay khi rule đó match với lưu lượng truy cập, nó sẽ ngay lập tức được áp dụng cho dù nó mâu thuẫn với một rule nào đó được đánh số lớn hơn trong danh sách. Type.loại lưu lượng, ví dụ SSH. Có thể chỉ định tất cả các loại lưu lượng truy cập hoặc phạm vi tùy chỉnh. Protocol. chỉ định giao thức cùng số giao thức chuẩn. Port range. port hoặc dải port lắng nghe của lưu lượng truy cập. Ví dụ: HTTP là 80. Source. [chỉ đối với Inbound rule] Xuất phát của lưu lượng truy cập (giá trị là dải CIDR). Destination. [chỉ đối với Outbound rule] Điểm đến của lưu lượng truy cập (giá trị là dải CIDR). Allow/Deny. chỉ rõ là Cho phép hoặc Từ chối lưu lượng truy cập. "
},
{
	"uri": "//localhost:1313/3-prerequiste/3.2-createsubnet/",
	"title": "Tạo Lambda Function",
	"tags": [],
	"description": "",
	"content": "Tạo Lambda Function Trong giao diện AWS Management Console\nChọn Lambda Trong giao diện Lambda Function\nChọn Function Chọn Create Function Thực hiện cấu hình Function\nFunction name, nhập Crawl_data Chọn Runtime Python 3.10 Chọn Create Function Hoàn thành tạo Function "
},
{
	"uri": "//localhost:1313/4-createec2server/4.2-connectec2/",
	"title": "Trích xuất thông tin từ file json",
	"tags": [],
	"description": "",
	"content": "Trích xuất thông tin từ file json(Chỉ xem) Để trích xuất các thông tin theo ý muốn bạn cần có một mức hiểu biết nhất định về cấu trúc file json(thử bằng cách print(response.json())) từ đoạn json trả về để thực hiện đi lần lượt vào từng cái list, dictionary để lấy dữ liệu mong muốn. Công cụ hỗ trợ dễ dàng làm việc với file json hơn https://dev.2fbuff.com/ View một đoạn json trả về. {\u0026#39;error\u0026#39;: 0, \u0026#39;data\u0026#39;: {\u0026#39;order_data\u0026#39;: {\u0026#39;details_list\u0026#39;: [{\u0026#39;status\u0026#39;: {\u0026#39;status_label\u0026#39;: {\u0026#39;text\u0026#39;: \u0026#39;label_order_completed\u0026#39;, \u0026#39;tl\u0026#39;: False}, \u0026#39;header_text\u0026#39;: {\u0026#39;text\u0026#39;: \u0026#39;order_status_text_completed_thank_you_shopping\u0026#39;, \u0026#39;tl\u0026#39;: False}, \u0026#39;header_image\u0026#39;: \u0026#39;https://deo.shopeemobile.com/shopee/shopee-orderprocessing-live-vn/completed.png\u0026#39;, \u0026#39;list_view_status_label\u0026#39;: {\u0026#39;text\u0026#39;: \u0026#39;label_completed\u0026#39;, \u0026#39;tl\u0026#39;: False}}, \u0026#39;shipping\u0026#39;: {\u0026#39;tracking_info\u0026#39;: {\u0026#39;driver_phone\u0026#39;: \u0026#39;\u0026#39;, \u0026#39;driver_name\u0026#39;: \u0026#39;\u0026#39;, \u0026#39;ctime\u0026#39;: 1696224180, \u0026#39;description\u0026#39;: \u0026#39;Đơn hàng đã được giao thành công\u0026#39;, \u0026#39;type\u0026#39;: 0}, \u0026#39;is_multi_parcel\u0026#39;: False, \u0026#39;num_parcels\u0026#39;: 1, \u0026#39;parcel_no\u0026#39;: 1}, \u0026#39;info_card\u0026#39;: {\u0026#39;order_id\u0026#39;: 149752100291872, \u0026#39;order_list_cards\u0026#39;: [{\u0026#39;shop_info\u0026#39;: {\u0026#39;shop_id\u0026#39;: 48311894, \u0026#39;shop_name\u0026#39;: \u0026#39;Bra \u0026amp; Knickers\u0026#39;, \u0026#39;user_id\u0026#39;: 48313282, \u0026#39;username\u0026#39;: \u0026#39;anannshop\u0026#39;, \u0026#39;portrait\u0026#39;: \u0026#39;d664c852e1100082b09a13d09457d93d\u0026#39;, \u0026#39;shop_tag\u0026#39;: 3}, \u0026#39;order_id\u0026#39;: 149752100291872, \u0026#39;product_info\u0026#39;: {\u0026#39;item_groups\u0026#39;: [{\u0026#39;items\u0026#39;: [{\u0026#39;item_id\u0026#39;: 1602031702, \u0026#39;model_id\u0026#39;: 9613089074, \u0026#39;shop_id\u0026#39;: 48311894, \u0026#39;name\u0026#39;: \u0026#39;Khăng Choàng Cổ Dạ Len Quàng Nam Nữ Cao Cấp Nhiều Màu Cashmere Hàng Đẹp Giá Rẻ\u0026#39;, \u0026#39;model_name\u0026#39;: \u0026#39;8 - da sáng\u0026#39;, \u0026#39;image\u0026#39;: \u0026#39;7e3e7ed202c224dae7641bab1ab0eefd\u0026#39;, \u0026#39;amount\u0026#39;: 1, \u0026#39;ext_info\u0026#39;: {\u0026#39;add_on_deal_id\u0026#39;: 0, \u0026#39;is_add_on_sub_item\u0026#39;: False, \u0026#39;free_return_day\u0026#39;: 0, \u0026#39;is_wholesale\u0026#39;: False, \u0026#39;is_pre_order\u0026#39;: False, \u0026#39;is_membership_gift\u0026#39;: False, \u0026#39;is_free_return\u0026#39;: False}, \u0026#39;status\u0026#39;: 1, \u0026#39;item_price\u0026#39;: 2890000000, \u0026#39;price_before_discount\u0026#39;: 6500000000, \u0026#39;order_price\u0026#39;: 2890000000, \u0026#39;snapshot_id\u0026#39;: 16436071430}], \u0026#39;num_items\u0026#39;: 1}], \u0026#39;total_num_items\u0026#39;: 1}}], \u0026#39;product_count\u0026#39;: 1, \u0026#39;subtotal\u0026#39;: 1445000000, \u0026#39;final_total\u0026#39;: 1445000000}, \u0026#39;primary_buttons\u0026#39;: [{\u0026#39;id\u0026#39;: 24}], \u0026#39;guarantee\u0026#39;: {\u0026#39;learn_more_url\u0026#39;: \u0026#39;https://shopee.vn/m/shopee-dam-bao\u0026#39;, \u0026#39;is_extend_enabled\u0026#39;: False}, \u0026#39;secondary_buttons\u0026#39;: [{\u0026#39;id\u0026#39;: 15}], \u0026#39;list_type\u0026#39;: 3}, ... } } Thực hiện trích xuất thông tin từ đoạn json thu được for i in range(0, 301, 5): params[\u0026#39;offset\u0026#39;] = i response = requests.get(\u0026#39;https://shopee.vn/api/v4/order/get_all_order_and_checkout_list\u0026#39;, headers=headers, params=params, cookies=cookies) if response.status_code == 200: data = response.json().get(\u0026#39;data\u0026#39;).get(\u0026#39;order_data\u0026#39;).get(\u0026#39;details_list\u0026#39;) if data is not None: for j in range(len(data)): order_info = data[j] main = order_info.get(\u0026#39;info_card\u0026#39;).get(\u0026#39;order_list_cards\u0026#39;)[0].get(\u0026#39;product_info\u0026#39;).get(\u0026#39;item_groups\u0026#39;)[0].get(\u0026#39;items\u0026#39;)[0] main1 = order_info.get(\u0026#39;info_card\u0026#39;).get(\u0026#39;order_list_cards\u0026#39;)[0].get(\u0026#39;shop_info\u0026#39;) main2 = order_info.get(\u0026#39;shipping\u0026#39;, {}).get(\u0026#39;tracking_info\u0026#39;, {}) product_id = main.get(\u0026#39;item_id\u0026#39;) shop_id = main1.get(\u0026#39;shop_id\u0026#39;) shop_name = main1.get(\u0026#39;shop_name\u0026#39;) name = main.get(\u0026#39;name\u0026#39;) price = main.get(\u0026#39;item_price\u0026#39;) / 100000 amount = main.get(\u0026#39;amount\u0026#39;) shop_name = main1.get(\u0026#39;shop_name\u0026#39;) status = main2.get(\u0026#39;description\u0026#39;, \u0026#39;Đã hủy\u0026#39;) if status == \u0026#39;Đã hủy\u0026#39;: status = None time = None else: time = datetime.datetime.fromtimestamp(main2.get(\u0026#39;ctime\u0026#39;, 0)) products.append({ \u0026#39;product_id\u0026#39;: product_id, \u0026#39;shop_id\u0026#39;: shop_id, \u0026#39;product_name\u0026#39;: name, \u0026#39;shop_name\u0026#39;: shop_name, \u0026#39;price\u0026#39;: price, \u0026#39;amount\u0026#39;: amount, \u0026#39;status\u0026#39;: status, \u0026#39;time\u0026#39;: time }) Thi thoảng code sẽ bị lỗi do shopee thay đổi cấu trúc của file json trả về. Khi gặp lỗi chỉ cần xóa cái key-value đó đi là được. Thông thường sẽ không có thay đổi nhiều.\n"
},
{
	"uri": "//localhost:1313/2-firewallinvpc/",
	"title": "Tường lửa trong VPC",
	"tags": [],
	"description": "",
	"content": "Tường lửa trong VPC Trong phần này, chúng ta sẽ cùng tìm hiểu các tính năng bảo mật cơ bản trong Amazon VPC như tính năng tường lửa Security Group và Network Access Control Lists.\nMột security group hoạt động như một tường lửa ảo cho EC2 Instance, giúp kiểm soát lưu lượng truy cập. Một Instance trong VPC có thể được gán tối đa 5 Security group do SG chỉ hoạt động ở tầng Instance mà không họat động ở tầng Subnet.\nSecurity groups hoạt động ở mức máy ảo, không phải ở mức subnet. Tuy nhiên, mỗi máy ảo trong một subnet có thể được gán với nhiều bộ Security group khác nhau.\nDanh sách kiểm soát truy cập mạng (ACL) là lớp bảo mật tùy chọn cho VPC, nó hoạt động như một tường lửa để kiểm soát lưu lượng ra và vào cho một hoặc nhiều subnet. Ta có thể thiết lập network ACL với các rule tương tự như security groups, nhằm bổ sung thêm một lớp bảo mật nữa cho VPC.\nNội dung Security groups Network ACLs "
},
{
	"uri": "//localhost:1313/3-prerequiste/3.3-createigw/",
	"title": "Add Layer",
	"tags": [],
	"description": "",
	"content": "Add Layer Trong giao diện Crawl_data\nKéo xuống cuối chọn Add Layer Thực hiện add layer\nChọn Specify an ARN Mở tab mới và truy cập link https://github.com/keithrozario/Klayers Trong phần README chọn List of ARNs Chọn version Python 3.10 Chọn region Singapore Chọn html Chọn các ARNs cần thiết\nRequest Boto3 Pandas Lần lượt copy và lặp lại add layer ở bước 2 vào Specify an ARN\nChọn Verify(nếu thấy hiện như dưới ảnh là ok) Sau đó nhấn Add. Sau khi thêm xong các layer sẽ có giao diện đủ 3 layer như sau: "
},
{
	"uri": "//localhost:1313/3-prerequiste/",
	"title": "Các bước chuẩn bị",
	"tags": [],
	"description": "",
	"content": "Các bước chuẩn bị Trong bài thực hành này, chúng ta sẽ xây dựng một mô hình theo sơ đồ bên dưới:\nNội dung Tạo S3 Bucket Tạo Lambda Function Add Layer "
},
{
	"uri": "//localhost:1313/1-introduce/1.3-internetgateway/",
	"title": "Layer",
	"tags": [],
	"description": "",
	"content": "Về Layer Layer ở đây là các package, bên ngoài các method gốc của ngôn ngữ lập trình thông thường. Để đơn giản hãy tưởng tượng layer tương tự như các thư viện trong python và mình chỉ việc import vào và sử dụng nó như bình thường(mặc định lambda function không có sẵn các thư viện mà phải thêm vào thông qua layers).\nMỗi Lambda function được add tối đa 5 layers.\nMột lambda function không thể thêm nhiều layer quá số bit cho trước nếu thêm quá sẽ hiện cảnh báo đỏ.\nCó 2 cách để thêm layer:\nThêm trực tiếp bằng cách zip các file trong thư viện gốc rồi đẩy lên layer (tốn thời gian để nén và có khi ko ăn với lambda hoặc cũng có thể zip thiếu). Cũng zip lại và tải trực tiếp vào lambda function. The layer bằng cách copy ARNs(của những người đã tạo trước đó) cùng với version tương ứng. Link ARNs tham khảo: https://github.com/keithrozario/Klayers\n"
},
{
	"uri": "//localhost:1313/4-createec2server/4.3-natgateway/",
	"title": "Thêm code vào lambda function",
	"tags": [],
	"description": "",
	"content": "Thêm code vào lambda function Truy cập Lambda Function\nChọn Function Chọn Crawl_data Kéo xuống và copy đoạn code sau vào lambda function, sửa thêm 1 số cái: Với cookie, header, params, response để copy ở phần trước đó.(nhớ tag lại) Thay đổi email cần gửi và email nhận. import json import requests import datetime import time import boto3 import os from io import BytesIO import pandas as pd import io import smtplib def crawl(): \u0026#34;\u0026lt;cookie-api\u0026gt;\u0026#34;# Lấy từ shopee từ bước products = [] for i in range(0, 301, 5): params[\u0026#39;offset\u0026#39;] = i response = requests.get(\u0026#39;https://shopee.vn/api/v4/order/get_all_order_and_checkout_list\u0026#39;, headers=headers, params=params, cookies=cookies) if response.status_code == 200: data = response.json().get(\u0026#39;data\u0026#39;).get(\u0026#39;order_data\u0026#39;).get(\u0026#39;details_list\u0026#39;) if data is not None: for j in range(len(data)): order_info = data[j] main = order_info.get(\u0026#39;info_card\u0026#39;).get(\u0026#39;order_list_cards\u0026#39;)[0].get(\u0026#39;product_info\u0026#39;).get(\u0026#39;item_groups\u0026#39;)[0].get(\u0026#39;items\u0026#39;)[0] main1 = order_info.get(\u0026#39;info_card\u0026#39;).get(\u0026#39;order_list_cards\u0026#39;)[0].get(\u0026#39;shop_info\u0026#39;) main2 = order_info.get(\u0026#39;shipping\u0026#39;, {}).get(\u0026#39;tracking_info\u0026#39;, {}) product_id = main.get(\u0026#39;item_id\u0026#39;) shop_id = main1.get(\u0026#39;shop_id\u0026#39;) shop_name = main1.get(\u0026#39;shop_name\u0026#39;) name = main.get(\u0026#39;name\u0026#39;) price = main.get(\u0026#39;item_price\u0026#39;) / 100000 amount = main.get(\u0026#39;amount\u0026#39;) shop_name = main1.get(\u0026#39;shop_name\u0026#39;) status = main2.get(\u0026#39;description\u0026#39;, \u0026#39;Đã hủy\u0026#39;) if status == \u0026#39;Đã hủy\u0026#39;: status = None time = None else: time = datetime.datetime.fromtimestamp(main2.get(\u0026#39;ctime\u0026#39;, 0)) products.append({ \u0026#39;product_id\u0026#39;: product_id, \u0026#39;shop_id\u0026#39;: shop_id, \u0026#39;product_name\u0026#39;: name, \u0026#39;shop_name\u0026#39;: shop_name, \u0026#39;price\u0026#39;: price, \u0026#39;amount\u0026#39;: amount, \u0026#39;status\u0026#39;: status, \u0026#39;time\u0026#39;: time }) return products def save_to_s3(products): df = pd.DataFrame(products) csv_buffer = io.BytesIO() df.to_csv(csv_buffer, index=False, encoding=\u0026#39;utf-8-sig\u0026#39;) csv_buffer.seek(0) csv_buffer_bytes = csv_buffer.getvalue() s3 = boto3.client(\u0026#39;s3\u0026#39;) bucket_name = \u0026#39;do-lab\u0026#39; file_key = \u0026#39;bill1.csv\u0026#39; s3.put_object(Body=csv_buffer_bytes, Bucket=bucket_name, Key=file_key, ContentType=\u0026#39;text/csv; charset=utf-8\u0026#39;) df[\u0026#39;time\u0026#39;] = pd.to_datetime(df[\u0026#39;time\u0026#39;]) start_of_current_month = pd.Timestamp.now().replace(day=1) start_of_previous_month = start_of_current_month - pd.offsets.MonthBegin(1) data_previous_month = df[df[\u0026#39;time\u0026#39;].dt.to_period(\u0026#39;M\u0026#39;) == start_of_previous_month.to_period(\u0026#39;M\u0026#39;)] total_price_previous_month = data_previous_month[\u0026#39;price\u0026#39;].sum() return total_price_previous_month def lambda_handler(event, context): products = crawl() result = save_to_s3(products) def send_email(subject, msg, toEmail): try: server = smtplib.SMTP(\u0026#39;smtp.gmail.com:587\u0026#39;) server.ehlo() server.starttls() server.login(FROM_EMAIL_ADDRESS, PASSWORD) message = \u0026#39;Subject: {}\\n\\n{}\u0026#39;.format(subject, msg) server.sendmail(FROM_EMAIL_ADDRESS, toEmail, message) server.quit() print(\u0026#34;Success: Email sent!\u0026#34;) except: print(\u0026#34;Email failed to send.\u0026#34;) FROM_EMAIL_ADDRESS = \u0026#34;\u0026lt;email-gửi\u0026gt;\u0026#34; TO_EMAIL_ADDRESSES = \u0026#34;\u0026lt;email-nhận\u0026gt;\u0026#34; PASSWORD = \u0026#34;\u0026lt;mật-khẩu-ứng-dụng-gmail\u0026#34; subject = \u0026#34;Notification of spending on shopping\u0026#34; msg = \u0026#34;Hello \\nYou are spend \u0026#34;+ str(result)+ \u0026#34; for shopping activities at shopee\u0026#34; send_email(subject, msg, TO_EMAIL_ADDRESSES) return { \u0026#39;statusCode\u0026#39;: 200, \u0026#39;body\u0026#39;: json.dumps(\u0026#39;Hello from Lambda!\u0026#39;) } Các phần cần sửa:\nbucket_name = \u0026laquo;do_lab\u0026raquo; // cái này để tùy ý bucket theo mong muốn.\n\u0026ldquo;\u0026laquo;cookie-api\u0026raquo;: Chỗ đã copy từ trang rút gọn api\nFROM_EMAIL_ADDRESS = \u0026ldquo;\u0026laquo;email-gửi\u0026raquo;\u0026rdquo;\nTO_EMAIL_ADDRESSES = \u0026ldquo;\u0026laquo;email-nhận\u0026raquo;\u0026rdquo;\nPASSWORD = \u0026ldquo;\u0026laquo;mật-khẩu-ứng-dụng-gmail\u0026raquo;\u0026rdquo;\nNhấn Deploy để lưu code: Code trên đã điều chỉnh để đơn giản nhất có thể là chỉ dùng để thu thập dữ liệu và xử lý đơn giản để tính được số tiền chi tiêu trong tháng trước đó và lưu file dữ liệu vào S3.\nCó thể phát triển thêm theo hướng là dùng thư viện pandas để vẽ các biểu đồ, doanh thu các ngày, phân tích đánh giá như sử dụng BI tool và gửi hết tất cả những phân tích đó qua email.\nKhi nhấn test code sẽ không chạy được và bị time out ngay lập tức. Lý do là do lambda function mặc định được cấu hình time out là 3s. Một funtion có thời gian timeout tối đa là 15p. Đây cùng là một trong những lý do lambda không được sử dụng để train các mô hình AI do thời gian time out tương đối thấp. Code trên thực hiện sẽ mất tầm 1p. Sau đây ta sẽ đi cấu hình thời gian time out cho Lambda.\nCấu hình time out Tại giao diện function chọn Configuration. Chọn General configuration. Chọn Edit. Nhập thông số: Description Increate amout time out. Memory 512. Time out 1. Nhấn Save. Hiện tại bạn có thể nhấn luôn phím test để test thử đoạn code. Nếu có mail gửi về là thành công được 80% rồi. Tiếp theo chúng ta sẽ đi cài lịch cho Lambda Function chạy vào đầu tháng. Và kết quả thu được sẽ là số tiền đã chi cho tháng trước.\nNếu có lỗi là do chỗ lấy thông tin từ web bị thay đổi. Hoặc là do cookies hết hạn và cần phải lặp lại các bước để lấy lại từ shopee.\n"
},
{
	"uri": "//localhost:1313/2-firewallinvpc/2.3-vpc-resource-map/",
	"title": "VPC Resource Map",
	"tags": [],
	"description": "",
	"content": "VPC Resource Map Để bắt đầu, hãy chọn một VPC đã tồn tại trong bảng điều khiển VPC. Trong phần chi tiết, hãy chọn tab Sơ đồ Tài nguyên. Tại đây, bạn có thể xem các tài nguyên trong VPC của bạn và mối quan hệ giữa các tài nguyên đó.\nKhi trỏ chuột qua một tài nguyên, bạn có thể xem các tài nguyên liên quan và các đường nối được đánh dấu. Nếu bạn nhấp chuột để chọn tài nguyên, bạn có thể xem một số dòng chi tiết và một liên kết để xem chi tiết của tài nguyên đã chọn.\nBắt đầu sử dụng trải nghiệm tạo VPC Bản đồ tài nguyên Amazon VPC hiện nay có sẵn trong tất cả các Vùng AWS mà Amazon VPC có sẵn, và bạn có thể bắt đầu sử dụng nó từ hôm nay.\nTrải nghiệm tạo bản đồ tài nguyên VPC và tạo mới chỉ hiển thị VPC, subnet, bảng định tuyến, cổng tiếp cận Internet, cổng NAT và cổng tiếp cận Amazon S3.\nBản đồ tài nguyên Amazon Virtual Private Cloud (VPC) là một tính năng cho phép bạn xem và quản lý tất cả các tài nguyên trong mạng VPC của bạn tại một nơi. Với bản đồ tài nguyên VPC, bạn có thể xem mối quan hệ giữa VPC, subnet, bảng định tuyến, cổng tiếp cận Internet, cổng NAT và cổng tiếp cận Amazon S3, giúp cho bạn hiểu rõ cấu trúc và kết nối của mạng của bạn.\nBạn có thể sử dụng bản đồ tài nguyên VPC để tạo, chỉnh sửa và xóa các tài nguyên VPC, cũng như hình dung luồng truyền dữ liệu mạng giữa chúng. Điều này rất hữu ích khi bạn làm việc với cấu hình VPC phức tạp và muốn đảm bảo mạng của bạn.\n"
},
{
	"uri": "//localhost:1313/4-createec2server/4.4.-createreachabilityanalyzer/",
	"title": "Add Trigger và permissions cho S3",
	"tags": [],
	"description": "",
	"content": "Add Trigger và permissions cho S3 Truy cập vào giao diện Lambda\nChọn Function Chọn Crawl_data Tại Function Crawl_data Chọn Add Trigger . Tại giao diện Add trigger Tại bucket chọn S3/workshoph. Event types chọn All object create events . Tích vào ô ở cuối xong ấn add trigger . Configure quyền cho S3 Tại giao diện function Chọn Configuration Chọn Permissions Click đường dẫn ở Role_name . Tại giao diện IAM Chọn Attach policies . Tìm AmazonS3FullAccess và tích vào. Add permissions . Trong dự án thực tế chúng ta sẽ set quyền rất chặt cho việc truy cập vào s3 tuy nhiên để bài lab này được thực hiện đơn giản hơn. Chúng ta sẻ sử dụng quyền cao nhất đối với S3(Full Acess).\n"
},
{
	"uri": "//localhost:1313/4-createec2server/",
	"title": "Lấy cookie từ shopee",
	"tags": [],
	"description": "",
	"content": "Lấy cookie từ shopee Ở bước này chúng ta sẽ thực hiện lấy cookie từ shopee\nTruy cập vào Shopee.com Chọn Đơn mua. Tại giao diện Đơn hàng Click chuột phải chọn inspect . Tại giao diện backend Click vào Network . Loading lại trang kém xuống tìm get_all_order_and_checkout_list?limit=5\u0026amp;offset=0 Di chuột vào phần copy. Chọn Copy all as cURL(bash) Mở tab mới và vào link: https://curlconverter.com/ Dán phần vừa copy vào curl command . Tiếp tục copy phần trả về phía dưới. Một điểm đáng chú ý nữa là thi thoảng web bị lỗi trong trường hợp copy nhiều lần thì cái trả về sẽ sinh ra nhiều code và liên tục bị trồng lên nhau. Nếu gặp trường hợp như vậy thì chỉ nên copy từ phần import đến hết respon().\nNội dung Lấy mật khẩu ứng dụng Gmail Trích xuất thông tin file json Thêm code vào Lambda Function "
},
{
	"uri": "//localhost:1313/5-vpnsitetosite/",
	"title": "Tạo schema cho EventBridge",
	"tags": [],
	"description": "",
	"content": "EventBridge Truy cập vào dịch vụ EventBridge Chọn Rule. Create rule. Điền các thông tin: Name send-email Description - optional notification for shopping Chọn Schedule. Chọn Continue in EventBridge Scheduler. Schedule pattern Chọn Recurring schedule. Tại Schedule type chọn Cron-based-schedule. Tại Cron expression chọn đặt lịch 2h chiều mỗi ngày. Flexible time windown chọn Off.\nSelect target Chọn AWS Lambda . Lambda function chọn Crawl_data. Tiếp tục chọn NEXT 2 lần tiếp theo. Click Create schedule Đợi đến thời gian chỉ định và check thông báo.\nKết quả: Do tháng trước mình không chi tiêu gì trên shopee nên kết quả sẽ là 0đ :)).\nFile bill.csv được lưu vào S3.\nTải xuống để kiểm tra dữ liệu:\nTừ file dữ liệu này bạn có thể tùy ý phân tích theo ý muốn.\nNội dung:\nEventBridge Tạo schedule "
},
{
	"uri": "//localhost:1313/6-cleanup/",
	"title": "Dọn dẹp tài nguyên",
	"tags": [],
	"description": "",
	"content": "Dọn dẹp tài nguyên Trong bài lab này chúng ta đã sử dụng các dịch vụ S3, Lambda Function, EventBridge. Các dịch vụ này đều có chi phí khá là rẻ và free cho tài khoản 12 tháng nên ko cần phải xóa tài nguyên.\nNếu vẫn muốn xóa thì đây là lần lượt các bước:\nXóa S3 Bucket Vào S3 chọn bucket và chọn workshoph và chọn Empty. sau đó chọn Delete làm theo các hiển thị tiếp theo để xóa.\nXóa shedule EventBridge Vào EventBridge chọn shedule và chọn send-email và chọn Delete.\nXóa Lambda function Vào Lambda function chọn function chọn Crawl_data và chọn Actions chọn Delete để xóa.\n"
},
{
	"uri": "//localhost:1313/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:1313/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]